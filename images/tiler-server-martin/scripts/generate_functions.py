#!/usr/bin/env python3
"""
Generates and executes Martin SQL tile functions.

Reads function definitions from config/functions.json, connects to PostgreSQL,
reads column names from materialized views, and creates PL/pgSQL functions
with hardcoded columns (no dynamic SQL at runtime).

Usage: python3 generate_functions.py
  Requires env vars: POSTGRES_HOST, POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
"""

import json
import os
import psycopg2

BASE_DIR = os.path.join(os.path.dirname(__file__), "..")
CONFIG_PATH = os.path.join(BASE_DIR, "config", "functions.json")
OUTPUT_DIR = os.path.join(BASE_DIR, "pg_functions")


def load_config():
    """Load function definitions from functions.json."""
    with open(CONFIG_PATH) as f:
        return json.load(f)


def get_columns(cur, table_name, exclude):
    """Get column names from a table/mview, excluding specified columns."""
    cur.execute("""
        SELECT attname
        FROM pg_attribute a
        JOIN pg_class c ON a.attrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relname = %s
          AND a.attnum > 0
          AND NOT a.attisdropped
          AND attname != ALL(%s)
        ORDER BY a.attnum
    """, (table_name, exclude))
    cols = [row[0] for row in cur.fetchall()]
    if not cols:
        print(f"  WARNING: No columns found for {table_name}")
    return cols


def generate_function_sql(func_def, columns_per_table):
    """Generate the CREATE FUNCTION SQL with hardcoded columns."""
    fn = func_def["function_name"]
    sl = func_def["source_layer"]
    zoom_mapping = func_def["zoom_mapping"]
    min_zoom = func_def.get("min_zoom")

    # Build the IF/ELSIF/ELSE blocks
    blocks = []
    for i, (max_zoom, table_name) in enumerate(zoom_mapping):
        cols = columns_per_table[table_name]
        col_list = ", ".join(f"t.{c}" for c in cols)

        query = (
            f"SELECT ST_AsMVT(q, '{sl}') INTO mvt FROM (\n"
            f"            SELECT {col_list},\n"
            f"                   ST_AsMVTGeom(t.geometry, bounds) AS geometry\n"
            f"            FROM public.{table_name} t\n"
            f"            WHERE t.geometry && bounds\n"
            f"        ) q;"
        )

        if i == 0 and max_zoom is not None:
            blocks.append(f"    IF z <= {max_zoom} THEN\n        {query}")
        elif max_zoom is None:
            if i == 0:
                # Single table, no IF needed
                blocks.append(f"    {query}")
            else:
                blocks.append(f"    ELSE\n        {query}")
        else:
            blocks.append(f"    ELSIF z <= {max_zoom} THEN\n        {query}")

    body = "\n".join(blocks)

    # Only add END IF when there are multiple zoom levels
    end_if = "\n    END IF;" if len(zoom_mapping) > 1 else ""

    # Early return for zooms below min_zoom
    min_zoom_guard = ""
    if min_zoom is not None and min_zoom > 0:
        min_zoom_guard = f"    IF z < {min_zoom} THEN\n        RETURN NULL;\n    END IF;\n\n"

    return f"""-- Function source for Martin: returns bytea MVT tiles
-- Auto-generated by generate_functions.py - do not edit manually
-- Source-layer name in MVT: "{sl}"
DROP FUNCTION IF EXISTS public.{fn}(integer, integer, integer, json);

CREATE OR REPLACE FUNCTION public.{fn}(
    z integer,
    x integer,
    y integer,
    query_params json DEFAULT '{{}}'::json
) RETURNS bytea AS $$
DECLARE
    bounds geometry := ST_TileEnvelope(z, x, y);
    mvt bytea;
BEGIN
{min_zoom_guard}{body}{end_if}

    RETURN mvt;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE;
"""


def main():
    config = load_config()
    groups = config["groups"]
    total = sum(len(g["functions"]) for g in groups)
    print(f"Loaded {total} functions in {len(groups)} groups from {CONFIG_PATH}")

    conn_str = "host={} port={} user={} password={} dbname={}".format(
        os.environ["POSTGRES_HOST"],
        os.environ["POSTGRES_PORT"],
        os.environ["POSTGRES_USER"],
        os.environ["POSTGRES_PASSWORD"],
        os.environ["POSTGRES_DB"],
    )

    print("Connecting to PostgreSQL...")
    conn = psycopg2.connect(conn_str)
    cur = conn.cursor()

    os.makedirs(OUTPUT_DIR, exist_ok=True)
    created = 0
    skipped = 0

    for group in groups:
        group_name = group["name"]
        print(f"\n[{group_name}]")

        for func_def in group["functions"]:
            fn = func_def["function_name"]
            exclude = func_def["exclude_columns"]
            zoom_mapping = [tuple(m) for m in func_def["zoom_mapping"]]
            func_def["zoom_mapping"] = zoom_mapping

            print(f"  {fn}...", end=" ")

            # Get columns for each table
            columns_per_table = {}
            skip = False
            for _, table_name in zoom_mapping:
                cols = get_columns(cur, table_name, exclude)
                if not cols:
                    skip = True
                    break
                columns_per_table[table_name] = cols

            if skip:
                print("SKIPPED (missing table)")
                skipped += 1
                continue

            # Generate SQL, write to file, execute
            sql = generate_function_sql(func_def, columns_per_table)

            sql_path = os.path.join(OUTPUT_DIR, f"{fn}.sql")
            with open(sql_path, "w") as f:
                f.write(sql)

            cur.execute(sql)
            conn.commit()
            created += 1
            print("OK")

    cur.close()
    conn.close()
    print(f"\nDone: {created} created, {skipped} skipped.")


if __name__ == "__main__":
    main()
