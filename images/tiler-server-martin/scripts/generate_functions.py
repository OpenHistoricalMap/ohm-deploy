#!/usr/bin/env python3
"""
Generates and executes Martin SQL tile functions.

Connects to PostgreSQL, reads column names from materialized views,
and creates PL/pgSQL functions with hardcoded columns (no dynamic SQL at runtime).

Usage: python3 generate_functions.py
  Requires env vars: POSTGRES_HOST, POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
"""

import os
import sys
import psycopg2

# Directory where generated .sql files are saved
OUTPUT_DIR = os.path.join(os.path.dirname(__file__), "..", "pg_functions")

# ============================================================================
# Function definitions
# ============================================================================
# Each entry defines a Martin tile function:
#   - function_name: name of the PL/pgSQL function (also the Martin endpoint)
#   - source_layer: source-layer name inside the MVT tile
#   - exclude_columns: columns to exclude (geometry is always excluded)
#   - zoom_mapping: list of (max_zoom, table_name) tuples, ordered by zoom
#                   last entry uses None for max_zoom (ELSE branch)

FUNCTIONS = [
    {
        "function_name": "land_ohm_lines",
        "source_layer": "land_ohm_lines",
        "exclude_columns": ["geometry"],
        "zoom_mapping": [
            (2, "mv_admin_boundaries_lines_z0_2"),
            (5, "mv_admin_boundaries_lines_z3_5"),
            (7, "mv_admin_boundaries_lines_z6_7"),
            (9, "mv_admin_boundaries_lines_z8_9"),
            (12, "mv_admin_boundaries_lines_z10_12"),
            (15, "mv_admin_boundaries_lines_z13_15"),
            (None, "mv_admin_boundaries_lines_z16_20"),
        ],
    },
    {
        "function_name": "transport_areas",
        "source_layer": "transport_areas",
        "exclude_columns": ["geometry", "tags"],
        "zoom_mapping": [
            (12, "mv_transport_areas_z10_12"),
            (15, "mv_transport_areas_z13_15"),
            (None, "mv_transport_areas_z16_20"),
        ],
    },
    {
        "function_name": "transport_lines",
        "source_layer": "transport_lines",
        "exclude_columns": ["geometry", "tags"],
        "zoom_mapping": [
            (5, "mv_transport_lines_z5"),
            (7, "mv_transport_lines_z6_7"),
            (9, "mv_transport_lines_z8_9"),
            (12, "mv_transport_lines_z10_12"),
            (15, "mv_transport_lines_z13_15"),
            (None, "mv_transport_lines_z16_20"),
        ],
    },
]


def get_columns(cur, table_name, exclude):
    """Get column names from a table/mview, excluding specified columns."""
    cur.execute("""
        SELECT attname
        FROM pg_attribute a
        JOIN pg_class c ON a.attrelid = c.oid
        JOIN pg_namespace n ON c.relnamespace = n.oid
        WHERE n.nspname = 'public'
          AND c.relname = %s
          AND a.attnum > 0
          AND NOT a.attisdropped
          AND attname != ALL(%s)
        ORDER BY a.attnum
    """, (table_name, exclude))
    cols = [row[0] for row in cur.fetchall()]
    if not cols:
        print(f"  WARNING: No columns found for {table_name}, skipping")
    return cols


def generate_function_sql(func_def, columns_per_table):
    """Generate the CREATE FUNCTION SQL with hardcoded columns."""
    fn = func_def["function_name"]
    sl = func_def["source_layer"]
    zoom_mapping = func_def["zoom_mapping"]

    # Build the IF/ELSIF/ELSE blocks
    blocks = []
    for i, (max_zoom, table_name) in enumerate(zoom_mapping):
        cols = columns_per_table[table_name]
        col_list = ", ".join(f"t.{c}" for c in cols)

        query = (
            f"SELECT ST_AsMVT(q, '{sl}') INTO mvt FROM (\n"
            f"            SELECT {col_list},\n"
            f"                   ST_AsMVTGeom(t.geometry, bounds) AS geometry\n"
            f"            FROM public.{table_name} t\n"
            f"            WHERE t.geometry && bounds\n"
            f"        ) q;"
        )

        if i == 0:
            blocks.append(f"    IF z <= {max_zoom} THEN\n        {query}")
        elif max_zoom is None:
            blocks.append(f"    ELSE\n        {query}")
        else:
            blocks.append(f"    ELSIF z <= {max_zoom} THEN\n        {query}")

    body = "\n".join(blocks)

    return f"""-- Function source for Martin: returns bytea MVT tiles
-- Auto-generated by generate_functions.py - do not edit manually
-- Source-layer name in MVT: "{sl}"
DROP FUNCTION IF EXISTS public.{fn}(integer, integer, integer, json);

CREATE OR REPLACE FUNCTION public.{fn}(
    z integer,
    x integer,
    y integer,
    query_params json DEFAULT '{{}}'::json
) RETURNS bytea AS $$
DECLARE
    bounds geometry := ST_TileEnvelope(z, x, y);
    mvt bytea;
BEGIN
{body}
    END IF;

    RETURN mvt;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE;
"""


def main():
    conn_str = "host={} port={} user={} password={} dbname={}".format(
        os.environ["POSTGRES_HOST"],
        os.environ["POSTGRES_PORT"],
        os.environ["POSTGRES_USER"],
        os.environ["POSTGRES_PASSWORD"],
        os.environ["POSTGRES_DB"],
    )

    print("Connecting to PostgreSQL...")
    conn = psycopg2.connect(conn_str)
    cur = conn.cursor()

    for func_def in FUNCTIONS:
        fn = func_def["function_name"]
        exclude = func_def["exclude_columns"]
        print(f"  Generating function: {fn}")

        # Get columns for each table in the zoom mapping
        columns_per_table = {}
        skip = False
        for _, table_name in func_def["zoom_mapping"]:
            cols = get_columns(cur, table_name, exclude)
            if not cols:
                skip = True
                break
            columns_per_table[table_name] = cols

        if skip:
            print(f"  SKIPPED {fn} (missing table)")
            continue

        # Generate the SQL
        sql = generate_function_sql(func_def, columns_per_table)

        # Write .sql file to pg_functions/
        os.makedirs(OUTPUT_DIR, exist_ok=True)
        sql_path = os.path.join(OUTPUT_DIR, f"{fn}.sql")
        with open(sql_path, "w") as f:
            f.write(sql)
        print(f"  Wrote: {sql_path}")

        # Execute in PostgreSQL
        cur.execute(sql)
        conn.commit()
        print(f"  Created function: {fn}")

    cur.close()
    conn.close()
    print("All functions created.")


if __name__ == "__main__":
    main()
